
## call，apply,bind实现
- call
``` javascript
Function.prototype.mcall = function(context){
    //传参第一个参数转对象，不传参直接去window
    let ctx = Object(context)||window;
    let fn = 'fn',res = '';
    while(ctx.hasOwnProperty(fn)){// 循环判断并重新赋值 ,防止上下文对象上本来就有同名方法
        fn = fn+Math.random();
    }  
    //把绑定函数作为上下文对象的方法
    ctx[fn] = this;
    //作为对象方法调用绑定函数，并把参数传入
    if(arguments.length>1){
       res = ctx[fn](...[...arguments].slice(1));
    }else{
       res=  ctx[fn]();
    }
    delete ctx[fn];
    //返回函数返回值
    return res;
}
```
- apply
``` javascript
Function.prototype.mapply = function(context,arr){
    let ctx = Object(context)||window;
    
    let fn = 'fn',res = '';
    while(ctx.hasOwnProperty(fn)){
        fn = fn+Math.random();
    }  

    ctx[fn] = this;

    if(arr){
       res = ctx[fn](...arr);
    }else{
       res=  ctx[fn]();
    }

    delete ctx[fn];
    return res;
}
```
- bind
```javascript
Function.prototype.mbind = function(context){
    context = context?Object(context):window;
    //保存argumets
   var mArguments = arguments, self = this;
    if(arguments.length>1){
        return function(){
            //借用apply
            self.apply(context,[...mArguments].slice(1))
        }
    }else{
        return function(){
            self.apply(context);
        }
    }

}
```

## new实现
```javascript
    function new(){
        //创建空对象
        let obj = {};
        //获取构造函数
        let Constructor = Array.prototype.shift.call(arguments);
        //绑定原型关系
        obj.__proto__ = Constructor.prototype;
         // 执行构造函数，即绑定 this，并且为这个新对象添加属性
         Constructor.apply(newObj, arguments);
        //返回新对象
        return obj;

    }

```

## Object.create

```javascript
Object.create = function (obj){
    //创建空构造函数F
    function F(){};
    //F的prottotype指向obj
    F.prtotype = obj;
    //返回F实例
    return new F();

}

```

## 实现一个异步任务并发控制
```javascript
async function sendRequest(list, max = 4) {
        return new Promise((resolve, reject) => {
          let index = 0;//
          let count = 0;//上传成功个数
          const start = () => {
            while (max > 0 && index < list.length) {
              //剩余位置-1
              max--;
              let chunk = list[index];
              index++;
              request().then((res) => {
                max++;//释放暂用位置
                count++;//上传成功数量+1
                if (count == list.length) {
                  resolve('完成了');
                } else {
                  start();
                }
              })
            }
          };

          start();
        });
      }

      function request(){
        return new Promise((resolve,reject)=>{
          setTimeout(()=>{
            console.log(1)
            resolve(1)
          },2000)
        })
      }

      var list = [1,2,3,4,5,6,7,8,9,0,1];
      sendRequest(list,4).then(res=>{
        console.log(res)
      }).catch(err=>{
        console.log('上传失败了')
      })

```
## 手写promise
- promise
```javascript
//判断变量是否是函数
function isFunction(variable) {
	return typeof variable === "function"
}

//promise构造函数
function MyPromise(handle) {
	if (!isFunction(handle)) {
		throw new Error('必须传入一个函数');
	}
	this.status = 'pending';//状态,默认等待状态
	this.value = '';//值
	this.onResolveCallbacks = [];//存放成功回调的数组
	this.onRejectCallbacks = [];//存放失败回调的数组
	var that = this;
	try {
		handle(resolve, reject);
	} catch (err) {
		reject(err)//有报错，状态直接变为rejected
	}

	function resolve(val) {
		if (that.status == 'pending') {
			that.status = 'resolved';
			that.value = val;
			that.onResolveCallbacks.forEach(fn => {
				fn();
			});
		}
	}

	function reject(err) {
		if (that.status == 'pending') {
			that.status = 'rejected';
			that.value = err;
			that.onRejectCallbacks.forEach(fn => {
				fn();
			});
		}
	}

}
```
- promise.then

```javascript
MyPromise.prototype.then = function (sucFun, faildFun) {//可选参数
	//如果没有传，只负责把值往后传
	sucFun = isFunction(sucFun) ? sucFun : value => value
	faildFun = isFunction(faildFun) ? faildFun : value => value
	var that = this;
   //先改变了状态
	if (this.status === 'resolved') {
		sucFun(this.value);
	}
	if (this.status === 'rejected') {
		faildFun(this.value);
	}
  //先指定了回调函数，状态还没改变
	if (this.status === 'pending') {
		//存住回调函数，在异步操作完成时调用
		this.onResolveCallbacks.push(() => {
			sucFun(this.value);
		});
		this.onRejectCallbacks.push(() => {
			faildFun(this.value);
		})
	}

	return this;

}
```
- promise.all
```javascript
Promise.allFun = (arr)=>{
    return new Promise((resolve,reject)=>{
        var resolveArr = [], rejectArr =[];
        for(var i=0;i<arr.length;i++){
            if(!(arr[i] instanceof Promise)){
                arr[i] = Promise.resolve(arr[i]);
            }
            arr[i].then(res=>{
                resolveArr.push(res);
                if(resolveArr.length==arr.length){
                    resolve(resolveArr);
                }
            }).catch(err=>{
                rejectArr.push(err);
                reject(rejectArr)
            })
        }
    })
}

```
- promise.race
```javascript
myPromise.race=function(arr){
    return new Promise(function(resolve,reject){
        for(var i in arr){
            arr[i].then(resolve,reject)
        }
    })
}
```